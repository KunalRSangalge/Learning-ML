




How-to guides | ü¶úÔ∏èüîó LangChain






Skip to main contentOur Building Ambient Agents with LangGraph course is now available on LangChain Academy!IntegrationsAPI ReferenceMoreContributingPeopleError referenceLangSmithLangGraphLangChain HubLangChain JS/TSv0.3v0.3v0.2v0.1üí¨SearchIntroductionTutorialsBuild a Question Answering application over a Graph DatabaseTutorialsBuild a simple LLM application with chat models and prompt templatesBuild a ChatbotBuild a Retrieval Augmented Generation (RAG) App: Part 2Build an Extraction ChainBuild an AgentTaggingBuild a Retrieval Augmented Generation (RAG) App: Part 1Build a semantic search engineBuild a Question/Answering system over SQL dataSummarize TextHow-to guidesHow-to guidesHow to use tools in a chainHow to use a vectorstore as a retrieverHow to add memory to chatbotsHow to use example selectorsHow to add a semantic layer over graph databaseHow to invoke runnables in parallelHow to stream chat model responsesHow to add default invocation args to a RunnableHow to add retrieval to chatbotsHow to use few shot examples in chat modelsHow to do tool/function callingHow to install LangChain packagesHow to add examples to the prompt for query analysisHow to use few shot examplesHow to run custom functionsHow to use output parsers to parse an LLM response into structured formatHow to handle cases where no queries are generatedHow to route between sub-chainsHow to return structured data from a modelHow to summarize text through parallelizationHow to summarize text through iterative refinementHow to summarize text in a single LLM callHow to use toolkitsHow to add ad-hoc tool calling capability to LLMs and Chat ModelsBuild an Agent with AgentExecutor (Legacy)How to construct knowledge graphsHow to partially format prompt templatesHow to handle multiple queries when doing query analysisHow to use built-in tools and toolkitsHow to pass through arguments from one step to the nextHow to compose prompts togetherHow to handle multiple retrievers when doing query analysisHow to add values to a chain's stateHow to construct filters for query analysisHow to configure runtime chain internalsHow deal with high cardinality categoricals when doing query analysisCustom Document LoaderHow to use the MultiQueryRetrieverHow to add scores to retriever resultsCachingHow to use callbacks in async environmentsHow to attach callbacks to a runnableHow to propagate callbacks  constructorHow to dispatch custom callback eventsHow to pass callbacks in at runtimeHow to split by characterHow to cache chat model responsesHow to handle rate limitsHow to init any model in one lineHow to track token usage in ChatModelsHow to add tools to chatbotsHow to split codeHow to do retrieval with contextual compressionHow to convert Runnables to ToolsHow to create custom callback handlersHow to create a custom chat model classCustom EmbeddingsHow to create a custom LLM classCustom RetrieverHow to create toolsHow to debug your LLM appsHow to load CSVsHow to load documents from a directoryHow to load HTMLHow to load JSONHow to load MarkdownHow to load Microsoft Office filesHow to load PDFsHow to load web pagesHow to create a dynamic (self-constructing) chainText embedding modelsHow to combine results from multiple retrieversHow to select examples from a LangSmith datasetHow to select examples by lengthHow to select examples by maximal marginal relevance (MMR)How to select examples by n-gram overlapHow to select examples by similarityHow to use reference examples when doing extractionHow to handle long text when doing extractionHow to use prompting alone (no tool calling) to do extractionHow to add fallbacks to a runnableHow to filter messagesHybrid SearchHow to use the LangChain indexing APIHow to inspect runnablesLangChain Expression Language CheatsheetHow to cache LLM responsesHow to track token usage for LLMsRun models locallyHow to get log probabilitiesHow to reorder retrieved results to mitigate the "lost in the middle" effectHow to split Markdown by HeadersHow to merge consecutive messages of the same typeHow to add message historyHow to migrate from legacy LangChain agents to LangGraphHow to retrieve using multiple vectors per documentHow to pass multimodal data to modelsHow to use multimodal promptsHow to create a custom Output ParserHow to use the output-fixing parserHow to parse JSON outputHow to retry when a parsing error occursHow to parse text from message objectsHow to parse XML outputHow to parse YAML outputHow to use the Parent Document RetrieverHow to use LangChain with different Pydantic versionsHow to add chat historyHow to get a RAG application to add citationsHow to do per-user retrievalHow to get your RAG application to return sourcesHow to stream results from your RAG applicationHow to split JSON dataHow to recursively split text by charactersResponse metadataHow to pass runtime secrets to runnablesHow to do "self-querying" retrievalHow to split text based on semantic similarityHow to chain runnablesHow to save and load LangChain objectsHow to split text by tokensHow to split HTMLHow to do question answering over CSVsHow to deal with large databases when doing SQL question-answeringHow to better prompt when doing SQL question-answeringHow to do query validation as part of SQL question-answeringHow to stream runnablesHow to stream responses from an LLMHow to use a time-weighted vector store retrieverHow to return artifacts from a toolHow to use chat models to call toolsHow to disable parallel tool callingHow to force models to call a toolHow to access the RunnableConfig from a toolHow to pass tool outputs to chat modelsHow to pass run time values to toolsHow to stream events from a toolHow to stream tool callsHow to convert tools to OpenAI FunctionsHow to handle tool errorsHow to use few-shot prompting with tool callingHow to add a human-in-the-loop for toolsHow to bind model-specific toolsHow to trim messagesHow to create and query vector storesConceptual guideAgentsArchitectureAsync programming with langchainCallbacksChat historyChat modelsDocument loadersEmbedding modelsEvaluationExample selectorsFew-shot promptingConceptual guideKey-value storesLangChain Expression Language (LCEL)MessagesMultimodalityOutput parsersPrompt TemplatesRetrieval augmented generation (RAG)RetrievalRetrieversRunnable interfaceStreamingStructured outputsTestingString-in, string-out llmsText splittersTokensTool callingToolsTracingVector storesWhy LangChain?Ecosystemü¶úüõ†Ô∏è LangSmithü¶úüï∏Ô∏è LangGraphVersionsv0.3v0.2Pydantic compatibilityMigrating from v0.0 chainsHow to migrate from v0.0 chainsMigrating from ConstitutionalChainMigrating from ConversationalChainMigrating from ConversationalRetrievalChainMigrating from LLMChainMigrating from LLMMathChainMigrating from LLMRouterChainMigrating from MapReduceDocumentsChainMigrating from MapRerankDocumentsChainMigrating from MultiPromptChainMigrating from RefineDocumentsChainMigrating from RetrievalQAMigrating from StuffDocumentsChainUpgrading to LangGraph memoryHow to migrate to LangGraph memoryHow to use BaseChatMessageHistory with LangGraphMigrating off ConversationBufferMemory or ConversationStringBufferMemoryMigrating off ConversationBufferWindowMemory or ConversationTokenBufferMemoryMigrating off ConversationSummaryMemory or ConversationSummaryBufferMemoryA Long-Term Memory AgentRelease policySecurity PolicyHow-to guidesOn this pageHow-to guides
Here you‚Äôll find answers to ‚ÄúHow do I‚Ä¶.?‚Äù types of questions.
These guides are goal-oriented and concrete; they're meant to help you complete a specific task.
For conceptual explanations see the Conceptual guide.
For end-to-end walkthroughs see Tutorials.
For comprehensive descriptions of every class and function see the API Reference.
Installation‚Äã

How to: install LangChain packages
How to: use LangChain with different Pydantic versions

Key features‚Äã
This highlights functionality that is core to using LangChain.

How to: return structured data from a model
How to: use a model to call tools
How to: stream runnables
How to: debug your LLM apps

Components‚Äã
These are the core building blocks you can use when building applications.
Chat models‚Äã
Chat Models are newer forms of language models that take messages in and output a message.
See supported integrations for details on getting started with chat models from a specific provider.

How to: do function/tool calling
How to: get models to return structured output
How to: cache model responses
How to: get log probabilities
How to: create a custom chat model class
How to: stream a response back
How to: track token usage
How to: track response metadata across providers
How to: use chat model to call tools
How to: stream tool calls
How to: handle rate limits
How to: few shot prompt tool behavior
How to: bind model-specific formatted tools
How to: force a specific tool call
How to: work with local models
How to: init any model in one line
How to: pass multimodal data directly to models

Messages‚Äã
Messages are the input and output of chat models. They have some content and a role, which describes the source of the message.

How to: trim messages
How to: filter messages
How to: merge consecutive messages of the same type

Prompt templates‚Äã
Prompt Templates are responsible for formatting user input into a format that can be passed to a language model.

How to: use few shot examples
How to: use few shot examples in chat models
How to: partially format prompt templates
How to: compose prompts together
How to: use multimodal prompts

Example selectors‚Äã
Example Selectors are responsible for selecting the correct few shot examples to pass to the prompt.

How to: use example selectors
How to: select examples by length
How to: select examples by semantic similarity
How to: select examples by semantic ngram overlap
How to: select examples by maximal marginal relevance
How to: select examples from LangSmith few-shot datasets

LLMs‚Äã
What LangChain calls LLMs are older forms of language models that take a string in and output a string.

How to: cache model responses
How to: create a custom LLM class
How to: stream a response back
How to: track token usage
How to: work with local models

Output parsers‚Äã
Output Parsers are responsible for taking the output of an LLM and parsing into more structured format.

How to: parse text from message objects
How to: use output parsers to parse an LLM response into structured format
How to: parse JSON output
How to: parse XML output
How to: parse YAML output
How to: retry when output parsing errors occur
How to: try to fix errors in output parsing
How to: write a custom output parser class

Document loaders‚Äã
Document Loaders are responsible for loading documents from a variety of sources.

How to: load PDF files
How to: load web pages
How to: load CSV data
How to: load data from a directory
How to: load HTML data
How to: load JSON data
How to: load Markdown data
How to: load Microsoft Office data
How to: write a custom document loader

Text splitters‚Äã
Text Splitters take a document and split into chunks that can be used for retrieval.

How to: recursively split text
How to: split HTML
How to: split by character
How to: split code
How to: split Markdown by headers
How to: recursively split JSON
How to: split text into semantic chunks
How to: split by tokens

Embedding models‚Äã
Embedding Models take a piece of text and create a numerical representation of it.
See supported integrations for details on getting started with embedding models from a specific provider.

How to: embed text data
How to: cache embedding results
How to: create a custom embeddings class

Vector stores‚Äã
Vector stores are databases that can efficiently store and retrieve embeddings.
See supported integrations for details on getting started with vector stores from a specific provider.

How to: use a vector store to retrieve data

Retrievers‚Äã
Retrievers are responsible for taking a query and returning relevant documents.

How to: use a vector store to retrieve data
How to: generate multiple queries to retrieve data for
How to: use contextual compression to compress the data retrieved
How to: write a custom retriever class
How to: add similarity scores to retriever results
How to: combine the results from multiple retrievers
How to: reorder retrieved results to mitigate the "lost in the middle" effect
How to: generate multiple embeddings per document
How to: retrieve the whole document for a chunk
How to: generate metadata filters
How to: create a time-weighted retriever
How to: use hybrid vector and keyword retrieval

Indexing‚Äã
Indexing is the process of keeping your vectorstore in-sync with the underlying data source.

How to: reindex data to keep your vectorstore in-sync with the underlying data source

Tools‚Äã
LangChain Tools contain a description of the tool (to pass to the language model) as well as the implementation of the function to call. Refer here for a list of pre-built tools.

How to: create tools
How to: use built-in tools and toolkits
How to: use chat models to call tools
How to: pass tool outputs to chat models
How to: pass run time values to tools
How to: add a human-in-the-loop for tools
How to: handle tool errors
How to: force models to call a tool
How to: disable parallel tool calling
How to: access the RunnableConfig from a tool
How to: stream events from a tool
How to: return artifacts from a tool
How to: convert Runnables to tools
How to: add ad-hoc tool calling capability to models
How to: pass in runtime secrets

Multimodal‚Äã

How to: pass multimodal data directly to models
How to: use multimodal prompts

Agents‚Äã
noteFor in depth how-to guides for agents, please check out LangGraph documentation.

How to: use legacy LangChain Agents (AgentExecutor)
How to: migrate from legacy LangChain agents to LangGraph

Callbacks‚Äã
Callbacks allow you to hook into the various stages of your LLM application's execution.

How to: pass in callbacks at runtime
How to: attach callbacks to a module
How to: pass callbacks into a module constructor
How to: create custom callback handlers
How to: use callbacks in async environments
How to: dispatch custom callback events

Custom‚Äã
All of LangChain components can easily be extended to support your own versions.

How to: create a custom chat model class
How to: create a custom LLM class
How to: create a custom embeddings class
How to: write a custom retriever class
How to: write a custom document loader
How to: write a custom output parser class
How to: create custom callback handlers
How to: define a custom tool
How to: dispatch custom callback events

Serialization‚Äã

How to: save and load LangChain objects

Use cases‚Äã
These guides cover use-case specific details.
Q&A with RAG‚Äã
Retrieval Augmented Generation (RAG) is a way to connect LLMs to external sources of data.
For a high-level tutorial on RAG, check out this guide.

How to: add chat history
How to: stream
How to: return sources
How to: return citations
How to: do per-user retrieval

Extraction‚Äã
Extraction is when you use LLMs to extract structured information from unstructured text.
For a high level tutorial on extraction, check out this guide.

How to: use reference examples
How to: handle long text
How to: do extraction without using function calling

Chatbots‚Äã
Chatbots involve using an LLM to have a conversation.
For a high-level tutorial on building chatbots, check out this guide.

How to: manage memory
How to: do retrieval
How to: use tools
How to: manage large chat history

Query analysis‚Äã
Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out this guide.

How to: add examples to the prompt
How to: handle cases where no queries are generated
How to: handle multiple queries
How to: handle multiple retrievers
How to: construct filters
How to: deal with high cardinality categorical variables

Q&A over SQL + CSV‚Äã
You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out this guide.

How to: use prompting to improve results
How to: do query validation
How to: deal with large databases
How to: deal with CSV files

Q&A over graph databases‚Äã
You can use an LLM to do question answering over graph databases.
For a high-level tutorial, check out this guide.

How to: add a semantic layer over the database
How to: construct knowledge graphs

Summarization‚Äã
LLMs can summarize and otherwise distill desired information from text, including
large volumes of text. For a high-level tutorial, check out this guide.

How to: summarize text in a single LLM call
How to: summarize text through parallelization
How to: summarize text through iterative refinement

LangChain Expression Language (LCEL)‚Äã
Should I use LCEL?LCEL is an orchestration solution. See our
concepts page for recommendations on when to
use LCEL.
LangChain Expression Language is a way to create arbitrary custom chains. It is built on the Runnable protocol.
LCEL cheatsheet: For a quick overview of how to use the main LCEL primitives.
Migration guide: For migrating legacy chain abstractions to LCEL.

How to: chain runnables
How to: stream runnables
How to: invoke runnables in parallel
How to: add default invocation args to runnables
How to: turn any function into a runnable
How to: pass through inputs from one chain step to the next
How to: configure runnable behavior at runtime
How to: add message history (memory) to a chain
How to: route between sub-chains
How to: create a dynamic (self-constructing) chain
How to: inspect runnables
How to: add fallbacks to a runnable
How to: pass runtime secrets to a runnable

LangGraph‚Äã
LangGraph is an extension of LangChain aimed at
building robust and stateful multi-actor applications with LLMs by modeling steps as edges and nodes in a graph.
LangGraph documentation is currently hosted on a separate site.
You can peruse LangGraph how-to guides here.
LangSmith‚Äã
LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain and LangGraph, and you can use it to inspect and debug individual steps of your chains and agents as you build.
LangSmith documentation is hosted on a separate site.
You can peruse LangSmith how-to guides here, but we'll highlight a few sections that are particularly
relevant to LangChain below:
Evaluation‚Äã

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.
To learn more, check out the LangSmith evaluation how-to guides.
Tracing‚Äã

Tracing gives you observability inside your chains and agents, and is vital in diagnosing issues.

How to: trace with LangChain
How to: add metadata and tags to traces

You can see general tracing-related how-tos in this section of the LangSmith docs.Edit this pagePreviousSummarize TextNextHow-to guidesInstallationKey featuresComponentsChat modelsMessagesPrompt templatesExample selectorsLLMsOutput parsersDocument loadersText splittersEmbedding modelsVector storesRetrieversIndexingToolsMultimodalAgentsCallbacksCustomSerializationUse casesQ&A with RAGExtractionChatbotsQuery analysisQ&A over SQL + CSVQ&A over graph databasesSummarizationLangChain Expression Language (LCEL)LangGraphLangSmithEvaluationTracingCommunityLangChain ForumTwitterGitHubOrganizationPythonJS/TSMoreHomepageBlogYouTubeCopyright ¬© 2025 LangChain, Inc.

